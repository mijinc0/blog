<!DOCTYPE html>
<html lang="ja" dir="ltr">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@mincoshi" />
  <meta property="og:url" content="https://mijinc0.github.io/blog/20190502_learn_typescript/" />
  <meta property="og:title" content="TypeScriptを学ぶ" />
  <meta property="og:image" content="https://github.com/mijinc0/blog/blob/image/featured/programing.png?raw=true" />

  <title>TypeScriptを学ぶ &middot; ByzantinePosts</title>
  <meta name="description" content="" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  
  
  
  
  <link href="https://mijinc0.github.io/blog/css/concated.min.css" rel="stylesheet">
  
  <style>
    body {
      background: #ecedef url("https://github.com/mijinc0/blog/blob/image/general/background.png?raw=true") repeat;
    }
  </style>
</head>

  <body class="single-body">
    <nav class="nav-bar side-padding">
  <h1 class="nav-header"><a href="https://mijinc0.github.io/blog/" class="nav-text">ByzantinePosts</a></h1>
  <div class="hamburger-menu">
    <button onclick="hamburgerMenuPressed.call(this)" aria-haspopup="true" aria-expanded="false" aria-controls="menu" aria-label="Menu">
      <span></span>
      <span></span>
    </button>
    <ul id="menu" class="hamburger-menu-overlay">
      <li><a href="https://mijinc0.github.io/blog/" class="hamburger-menu-overlay-link">Home</a></li>
      <li><a href="https://mijinc0.github.io/blog/categories/android" class="hamburger-menu-overlay-link">Android</a></li><li><a href="https://mijinc0.github.io/blog/categories/game_dev" class="hamburger-menu-overlay-link">Game dev</a></li><li><a href="https://mijinc0.github.io/blog/categories/glsl" class="hamburger-menu-overlay-link">Glsl</a></li><li><a href="https://mijinc0.github.io/blog/categories/js_ts" class="hamburger-menu-overlay-link">Js ts</a></li><li><a href="https://mijinc0.github.io/blog/categories/nem2" class="hamburger-menu-overlay-link">Nem2</a></li><li><a href="https://mijinc0.github.io/blog/categories/programing_tools" class="hamburger-menu-overlay-link">Programing tools</a></li><li><a href="https://mijinc0.github.io/blog/categories/typescript" class="hamburger-menu-overlay-link">Typescript</a></li><li><a href="https://mijinc0.github.io/blog/categories/vue" class="hamburger-menu-overlay-link">Vue</a></li>
    </ul>
  </div>
</nav>
    <main class="content side-text-padding">
      <article class="post dropcase">
        <header class="post-header">
        	<h1 class="post-title">TypeScriptを学ぶ</h1>
          <p class="post-date">Posted <time datetime="2019-05-02">May 2, 2019</time></p>
        </header>
        
        <picture class="post-figure">
            
            <source srcset="https://github.com/mijinc0/blog/blob/image/featured/programing.png?raw=true">
          <img src="https://github.com/mijinc0/blog/blob/image/featured/programing.png?raw=true" alt="programing image">
        </picture>
        
        <p>初めてTypescriptに触った時に書いたメモ。</p>
<h2 id="概要">概要</h2>
<p>そもそもtypescriptはjavascriptにクラスベースのオブジェクト思考を持ち込んだもので、コンパイルすることによってjavascriptのソースコードを吐き出してくれる。これは、クライアントサイドでも、サーバーサイド(NodeJS)でも使用できる。（ただのjavascriptのソースなので）</p>
<p>つまり、typescriptはコンパイラを入れることで開発環境を構築する。</p>
<h2 id="環境構築">環境構築</h2>
<h3 id="nodejsのインストール">Node.jsのインストール</h3>
<p>これは生成したスクリプトの実行場所として<code>Node.js</code>を使用するという意味である。</p>
<p>rubyでいうところの<code>rbenv</code>のようなものがNode.jsにもある。<code>n</code>というライブラリだ。</p>
<h3 id="npm">npm</h3>
<p><code>Node.js</code>をインストールすると、<code>nvm</code>と<code>npm</code>コマンドが使えるようになる。<code>nvm</code>はjavaでいう<code>jvm</code>のようなもの、<code>npm</code>はパッケージ管理ソフトになる。</p>
<h3 id="npm-init">npm init</h3>
<p><code>npm</code>にはグローバルな環境にパッケージをインストールする<code>-g</code>オプションがあるが、基本的には<code>-g</code>オプションを取ってローカルにインストールすれば良い。このとき、開発時に必要なだけのライブラリは<code>-D</code>(<code>--save-dev</code>のエイリアス)を付けることで、後述する<code>package.json</code>に開発時のみで依存するパッケージであると明記される。</p>
<p>ローカルにインストール、もっと言えば、プロダクトと毎にインストールすることになるわけだが、こうすることでプロダクト毎にライブラリのバージョンを管理できる。（嵩むが）</p>
<p>その時、最初に行うのが<code>npm init</code>コマンドで、対話型で情報を入力すると<code>package.json</code>というファイルを出力してくれる。rubyのbundlerで言うところのgemspecファイルみたいなもの。このファイルがないと、ローカルインストールしたときに警告が出る。これは、ローカルインストール=プロダクト毎に管理しているということを<code>npm</code>が意識しているのだと思う。</p>
<h3 id="node_module-ディレクトリ">node_module ディレクトリ</h3>
<p>ローカルにインストールすると、<code>node_modules</code>ディレクトリから始まることが分かる。これは、例えば同じ場所で別の<code>npm</code>パッケージをインストールすると、やはり<code>node_module</code>に入れられる。</p>
<p>もし、グローバル(<code>-g</code>)オプションを付けたら、<code>/usr/local/lib</code>ディレクトリに<code>node_module</code>ディレクトリが生成され、そこに入れられる。</p>
<p>グローバルの場合は、さらにこの中にあるスクリプトを呼び出すスクリプトが<code>/usr/local/bin</code>に生成
されるということだと思う。</p>
<h3 id="コマンド系ライブラリ">コマンド系ライブラリ</h3>
<p>ローカルにインストールして管理するのは良いが、グローバルな環境にパッケージをインストールするときと違い、ローカルにインストールするとライブラリは良いがコマンド群はそのままでは使えない。グローバルにインストールすると<code>/usr/local/bin</code>ディレクトリにスクリプトがインストールされるが、ローカルだとローカルインストールしたカレントディレクトリに<code>.bin</code>ディレクトリが生成され、そこにコマンド実行用スクリプトが入れられる。</p>
<p>なので、<code>npm run &lt;コマンドファイルのパス&gt;</code>で実行しないといけなくなるわけだが、これを簡単に実行してくれるものが<code>npm</code>にバンドルされるようになっている。<code>npx</code>という。</p>
<p><code>npx</code>は、 <strong>カレントディレクトリ/.binにあるnpmパッケージのコマンドを実行する</strong> 又は、 <strong>存在しないコマンドでアレば一時的にインストールして実行する</strong> 機能を持ったコマンド。コレを使うには、単純にプロダクトのルートディレクトリ上で</p>
<pre><code>$ npx コマンド名
</code></pre><p>と打てば良い。</p>
<h3 id="コンパイラのインストール">コンパイラのインストール</h3>
<p>typescriptは<code>npm</code>からインストール出来る。</p>
<pre><code>$ npm install -D typescript
</code></pre><h3 id="実行用コマンドをインストール">実行用コマンドをインストール</h3>
<p>現状だと作成したtypescriptソースをコンパイルして実行しするまでの手順は下記のようになる。</p>
<ol>
<li>typescriptでソースを書く</li>
<li>tsc（コンパイラ）でtsファイルをjsファイルに変換する</li>
<li>jsファイルをnodeコマンドで実行する</li>
</ol>
<p>だが、だるい。なので、<code>ts-node</code>というコマンドをインストールする。これを使えば、<code>ts</code>ファイルをそのまま実行できる（<code>ts</code>ファイルを指定すれば2,3の動作をまとめて行うような動作をしてくれる）。</p>
<pre><code>$ npm install -D ts-node
</code></pre><h2 id="typescript触ってみる">typescript触ってみる</h2>
<p>基本的にjavascriptで表現できるものはtypescriptでも同様に表現でき、それらにtypescriptならではの表現の許可が追加されているのだと考えれば良い。</p>
<h2 id="タイプアノテーション">タイプアノテーション</h2>
<pre><code>function function_name( var: string )
</code></pre><p>typescriptでは、上記のように方のアノテーションを指定できる。(stringのほう)
引数とかでなくても指定できる。</p>
<h2 id="変数">変数</h2>
<p><code>var</code>,<code>let</code>,<code>const</code>がある。これはjavascriptと同じ。</p>
<p><code>var</code>はスコープを持たないjavascriptに最初からあった変数。なので、使いにくい。他の言語で言うグローバル変数のように振る舞うので、関数の中だろうがその中のブロック内だろうがアクセスされる。 <strong>ただし、varは関数内で再定義すると、その関数内では別の変数を新たに宣言したように振る舞い、関数から外に出ると再び別の場所で代入された値に戻る</strong></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">var</span> str:<span style="color:#458;font-weight:bold">string</span> <span style="font-weight:bold">=</span> <span style="color:#b84">&#34;this is var str&#34;</span>

<span style="font-weight:bold">function</span> demo_a(){

  <span style="font-weight:bold">if</span>(<span style="font-weight:bold">true</span>){
    console.log( str ) <span style="color:#998;font-style:italic">// =&gt; this is var str
</span><span style="color:#998;font-style:italic"></span>  }

  console.log( str ) <span style="color:#998;font-style:italic">// =&gt; this is var str
</span><span style="color:#998;font-style:italic"></span>}

demo();

console.log( str ) <span style="color:#998;font-style:italic">// =&gt; this is var str
</span></code></pre></div><p>上記だとただのグローバル変数のように振る舞う。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">var</span> str:<span style="color:#458;font-weight:bold">string</span> <span style="font-weight:bold">=</span> <span style="color:#b84">&#34;this is var str&#34;</span>

<span style="font-weight:bold">function</span> demo_a(){

  <span style="font-weight:bold">if</span>(<span style="font-weight:bold">true</span>){
    <span style="font-weight:bold">var</span> str:<span style="color:#458;font-weight:bold">string</span> <span style="font-weight:bold">=</span> <span style="color:#b84">&#34;this is re-declare var str&#34;</span>
    console.log( str ) <span style="color:#998;font-style:italic">// =&gt; this is re-declare var str
</span><span style="color:#998;font-style:italic"></span>  }

  console.log( str ) <span style="color:#998;font-style:italic">// =&gt; this is re-declare var str
</span><span style="color:#998;font-style:italic"></span>}

demo();

console.log( str ) <span style="color:#998;font-style:italic">// =&gt; this is var str
</span></code></pre></div><p>上記だと関数内だけ、新たに宣言されたように振る舞う。しかし、ここで&hellip;</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">var</span> str:<span style="color:#458;font-weight:bold">string</span> <span style="font-weight:bold">=</span> <span style="color:#b84">&#34;this is var str&#34;</span>

<span style="font-weight:bold">function</span> demo_a(){

  <span style="color:#998;font-style:italic">// falseにかえると...
</span><span style="color:#998;font-style:italic"></span>  <span style="font-weight:bold">if</span>(<span style="font-weight:bold">false</span>){
    <span style="font-weight:bold">var</span> str:<span style="color:#458;font-weight:bold">string</span> <span style="font-weight:bold">=</span> <span style="color:#b84">&#34;this is re-declare var str&#34;</span>
    console.log( str )
  }

  console.log( str ) <span style="color:#998;font-style:italic">// =&gt; undefined
</span><span style="color:#998;font-style:italic"></span>}

demo();

console.log( str ) <span style="color:#998;font-style:italic">// =&gt; this is var str
</span></code></pre></div><p>何故か関数内が<code>undefined</code>になってしまう。関数内で<code>var</code>を再定義するのは基本的にやめたほうが良さげ。素直にグローバルとしてどこかで定義してそれをずっと使いまわし、ほかは後述する<code>let</code>と<code>const</code>を使用するのが良い。</p>
<p><code>let</code>はその変数が宣言されたブロックにスコープが制限される変数。</p>
<p><code>const</code>はスコープの制限は<code>let</code>と同じだが、定数になる。スコープが制限されているもので、一時的に使われるだけのもののため、基本的には特別再代入されるわけではない変数はこの<code>const</code>を使おうというお作法があるらしい。</p>
<p>再代入が必要なのは、例えばfor文で使われるカウンタのような変数。</p>
<ul>
<li>基本的には<code>const</code></li>
<li>再代入必要であれば<code>let</code></li>
<li>グローバルとしては<code>var</code></li>
</ul>
<p>らしい。</p>
<h3 id="変数letの性格">変数letの性格</h3>
<p>変数<code>let</code>は同じスコープ内で同じ変数を宣言するとコンパイラがエラーを吐くようになっている。しかし、下記のような宣言は許される。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">let</span> num:<span style="color:#458;font-weight:bold">number</span> <span style="font-weight:bold">=</span> <span style="color:#099">1</span>;

<span style="font-weight:bold">function</span> demo(){
  <span style="font-weight:bold">let</span> num:<span style="color:#458;font-weight:bold">number</span> <span style="font-weight:bold">=</span> <span style="color:#099">2</span>;

  <span style="font-weight:bold">if</span>(<span style="font-weight:bold">true</span>){
    <span style="font-weight:bold">let</span> num:<span style="color:#458;font-weight:bold">number</span> <span style="font-weight:bold">=</span> <span style="color:#099">3</span>;
    console.log( num )
  }

  console.log( num )
}

console.log( num )

demo();
</code></pre></div><p>特に変なのは<code>function</code>内の<code>if</code>の中と外の関係だろう。スコープが変われば同じ名前の変数を宣言できてしまう。これは、コンパイルすれば分かるが<code>変数_1</code>,<code>変数_2</code>のように名前をコンパイラが付け足して解決している。</p>
<h2 id="データ型">データ型</h2>
<p>typescriptはjavascript同様でデータ型を管理している。</p>
<ul>
<li>String</li>
<li>Boolean</li>
<li>Array</li>
<li>Tuple</li>
<li>preserveConstEnumsAny</li>
<li>Union</li>
<li>Any</li>
<li>Void</li>
<li>Never</li>
</ul>
<p>そしてそれらは関数を保持している。</p>
<h2 id="型推論-type-inference">型推論 (Type inference)</h2>
<p>typescriptはデータ型を指定しなくても型推論を行うので、例えば下記のようなものはコンパイルエラーになる。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">var</span> a <span style="font-weight:bold">=</span> <span style="color:#b84">&#34;string&#34;</span>;
<span style="font-weight:bold">var</span> b <span style="font-weight:bold">=</span> <span style="color:#099">1</span>;

a <span style="font-weight:bold">=</span> b <span style="color:#998;font-style:italic">// コンパイルエラー
</span></code></pre></div><h2 id="キャスト型アサーション-type-assertion">キャスト=型アサーション (Type Assertion)</h2>
<p><code>any</code>型で捉えた変数をキャストしたいときなど、下記のように書くことでキャストできる。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">let</span> a: <span style="color:#458;font-weight:bold">any</span> <span style="font-weight:bold">=</span> <span style="color:#099">123</span>
<span style="font-weight:bold">let</span> b <span style="font-weight:bold">=</span> <span style="font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">number</span><span style="font-weight:bold">&gt;</span> a
</code></pre></div><p>上記でキャストが無い場合、<code>b</code>の方は<code>any</code>になるが、キャストされているので<code>number</code>になる。</p>
<h2 id="関数の戻値">関数の戻値</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#998;font-style:italic">//              コレが戻値
</span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">function</span> func() <span style="font-weight:bold">:</span> <span style="color:#458;font-weight:bold">string</span> {
  ...
}
</code></pre></div><h2 id="アロー関数arrow-function">アロー関数(Arrow Function)</h2>
<p>ラムダ式のようなもの</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript">(param1 , param2 ...) <span style="font-weight:bold">=&gt;</span> { <span style="color:#a61717;background-color:#e3d2d2">処理</span> }
</code></pre></div><p>一行で書ききれるならブロックはなくても良い。</p>
<h2 id="interface">interface</h2>
<p>typescriptの<code>interface</code>は変数と関数の雛形を定義できる構造体であり、クラスによって実装させることも出来る（javaのように）。直接関数を中に定義することはできない。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">interface</span> InterfaceHuman{
  name: <span style="color:#458;font-weight:bold">string</span>;
  age: <span style="color:#458;font-weight:bold">number</span>;
  say<span style="font-weight:bold">:</span> (other) <span style="font-weight:bold">=&gt;</span> <span style="font-weight:bold">void</span>;
  getName()<span style="font-weight:bold">:</span> <span style="color:#458;font-weight:bold">number</span>;
}
</code></pre></div><p>割とややこしいので一個ずつ書いていく。</p>
<h3 id="変数の型を定義するのに利用する">変数の型を定義するのに利用する</h3>
<p>シンプルに、構造体として利用するパターン。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">interface</span> Human{
  name: <span style="color:#458;font-weight:bold">string</span>;
  age: <span style="color:#458;font-weight:bold">number</span>;
}

<span style="font-weight:bold">let</span> alice: <span style="color:#458;font-weight:bold">Human</span> <span style="font-weight:bold">=</span> { name<span style="font-weight:bold">:</span> <span style="color:#b84">&#34;alice&#34;</span>, age: <span style="color:#458;font-weight:bold">18</span> };

console.log( alice.name <span style="font-weight:bold">+</span> alice.age )
</code></pre></div><h3 id="関数の型を定義するのに利用する">関数の型を定義するのに利用する</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">interface</span> SomeStrFunc{
  <span style="color:#998;font-style:italic">// ( 引数の型 ): 戻り値の型;
</span><span style="color:#998;font-style:italic"></span>  ( <span style="color:#458;font-weight:bold">string</span> )<span style="font-weight:bold">:</span> <span style="color:#458;font-weight:bold">string</span>;
}

<span style="font-weight:bold">function</span> addHello( name: <span style="color:#458;font-weight:bold">string</span> )<span style="font-weight:bold">:</span> <span style="color:#458;font-weight:bold">string</span> {
  <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;Hello, &#34;</span> <span style="font-weight:bold">+</span> name
}

<span style="font-weight:bold">let</span> ssf: <span style="color:#458;font-weight:bold">SomeStrFunc</span> <span style="font-weight:bold">=</span> addHello;

console.log( addHello( <span style="color:#b84">&#34;alice&#34;</span> ) )
</code></pre></div><p>javascriptは変数に引数なし関数を代入すると関数オブジェクト的なものが作れる。その型をインターフェースで定義できる。</p>
<h3 id="配列の型を定義するのに利用する">配列の型を定義するのに利用する</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">interface</span> NumList{
  [ index: <span style="color:#458;font-weight:bold">number</span> ]<span style="font-weight:bold">:</span> <span style="color:#458;font-weight:bold">number</span>;
}

<span style="font-weight:bold">const</span> numArr: <span style="color:#458;font-weight:bold">NumList</span> <span style="font-weight:bold">=</span> [<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>];

console.log( numArr[<span style="color:#099">0</span>] )
console.log( numArr[<span style="color:#099">1</span>] )
console.log( numArr[<span style="color:#099">2</span>] )
</code></pre></div><p><code>[ index: number ]: number</code>がキモ。次に書く。</p>
<h3 id="インデックスシグネチャ">インデックスシグネチャ</h3>
<p><code>[ index: &lt;インデックスの型（string又はnumberのみ指定可能）&gt; ]: &lt;値（戻り値）の型&gt;</code>はインデックスシグネチャと呼ばれ、下記のように使える。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">interface</span> BoolList{
  [ index: <span style="color:#458;font-weight:bold">number</span> ]<span style="font-weight:bold">:</span> <span style="font-weight:bold">boolean</span>;
}

<span style="font-weight:bold">const</span> boolArr: <span style="color:#458;font-weight:bold">BoolList</span> <span style="font-weight:bold">=</span> {};
boolArr[<span style="color:#099">0</span>] <span style="font-weight:bold">=</span> <span style="font-weight:bold">true</span>
boolArr[<span style="color:#099">1</span>] <span style="font-weight:bold">=</span> <span style="font-weight:bold">false</span>

console.log( boolArr[<span style="color:#099">0</span>] ) <span style="color:#998;font-style:italic">// true
</span><span style="color:#998;font-style:italic"></span>console.log( boolArr[<span style="color:#099">1</span>] ) <span style="color:#998;font-style:italic">// false
</span><span style="color:#998;font-style:italic"></span>console.log( boolArr[<span style="color:#099">2</span>] ) <span style="color:#998;font-style:italic">// undefined
</span></code></pre></div><p>上記の<code>number</code>の場合。下記は<code>string</code>の場合</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">interface</span> BoolList{
  [ index: <span style="color:#458;font-weight:bold">string</span> ]<span style="font-weight:bold">:</span> <span style="font-weight:bold">boolean</span>;
}

<span style="font-weight:bold">const</span> boolArr: <span style="color:#458;font-weight:bold">BoolList</span> <span style="font-weight:bold">=</span> {};
boolArr[<span style="color:#b84">&#34;flag1&#34;</span>] <span style="font-weight:bold">=</span> <span style="font-weight:bold">true</span>
boolArr[<span style="color:#b84">&#34;flag2&#34;</span>] <span style="font-weight:bold">=</span> <span style="font-weight:bold">false</span>

console.log( boolArr[<span style="color:#b84">&#34;flag1&#34;</span>] ) <span style="color:#998;font-style:italic">// true
</span><span style="color:#998;font-style:italic"></span>console.log( boolArr[<span style="color:#b84">&#34;flag2&#34;</span>] ) <span style="color:#998;font-style:italic">// false
</span><span style="color:#998;font-style:italic"></span>console.log( boolArr[<span style="color:#b84">&#34;flag3&#34;</span>] ) <span style="color:#998;font-style:italic">// undefined
</span></code></pre></div><p>ちなみに、下記のうようなことも可能。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">interface</span> Test{
  [ index: <span style="color:#458;font-weight:bold">string</span> ]<span style="font-weight:bold">:</span> <span style="color:#999">Function</span>;
}

<span style="font-weight:bold">const</span> ti: <span style="color:#458;font-weight:bold">Test</span> <span style="font-weight:bold">=</span> {};

ti[<span style="color:#b84">&#34;func&#34;</span>] <span style="font-weight:bold">=</span> <span style="font-weight:bold">function</span>(){ console.log(<span style="color:#b84">&#34;call function&#34;</span>) };

ti.func();
</code></pre></div><p>インデックスシグネチャで動的に関数を追加できてしまう。インデックスシグネチャは型安全を崩壊させるとかいうのはコレを言っているのかな？</p>
<h2 id="オプショナルプロパティ">オプショナルプロパティ</h2>
<p>インターフェースに定義される方をプロパティと呼ぶが、あってもなくても良い任意のプロパティも指定可能。プロパティ名の後ろに<code>?</code>をつければ良い。</p>
<h2 id="読み込み専用プロパティ">読み込み専用プロパティ</h2>
<p>プロパティ宣言時、先頭に<code>readonly</code>をつければ良い。</p>
<h2 id="継承">継承</h2>
<p><code>extends</code>で継承可能</p>
<h2 id="実装">実装</h2>
<p><code>implements</code>でclassによる実装が可能。この辺はjavaによく似ている。</p>
<h2 id="複合型">複合型</h2>
<p>以上の要素を複合して型を定義することも出来る。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">interface</span> Human{
  name: <span style="color:#458;font-weight:bold">string</span>;
  age: <span style="color:#458;font-weight:bold">number</span>;

  say( <span style="color:#458;font-weight:bold">string</span> )<span style="font-weight:bold">:</span> <span style="font-weight:bold">void</span>;
}

<span style="font-weight:bold">function</span> say( name: <span style="color:#458;font-weight:bold">string</span> )<span style="font-weight:bold">:</span> <span style="font-weight:bold">void</span> {
  console.log( <span style="color:#b84">&#34;hello, &#34;</span> <span style="font-weight:bold">+</span> name  );
}

<span style="font-weight:bold">const</span> alice: <span style="color:#458;font-weight:bold">Human</span> <span style="font-weight:bold">=</span> { name<span style="font-weight:bold">:</span> <span style="color:#b84">&#34;alice&#34;</span>, age: <span style="color:#458;font-weight:bold">19</span>, say };

console.log( alice.name );
console.log( alice.age  );

alice.say(<span style="color:#b84">&#34;bob&#34;</span>);
</code></pre></div><p>上記の場合、<code>Human</code>型は&hellip;</p>
<ul>
<li><code>name</code>という<code>string</code>型のプロパティ</li>
<li><code>age</code>という<code>number</code>型のプロパティ</li>
<li>引数の型が<code>string</code>,戻り地が<code>void</code>の<code>say</code>と名付けられた関数</li>
</ul>
<p>を持つ型であると定義できる。</p>
<h2 id="class">class</h2>
<p>やっと<code>class</code>にたどり着いた。</p>
<p><code>class</code>は&hellip;</p>
<ul>
<li>コンストラクタを持ち</li>
<li>プロパティを保持でき</li>
<li>メソッドを定義できる</li>
</ul>
<p>型の宣言であると言えそう。</p>
<p>インターフェースはイニシャライザを持たず、あくまで型の宣言だけが出来るものであり（これはjavaのインターフェースに通ずるものがある）ププロパティに値を持たせて保持させることや、関数を直接実装して保持させることができなかったが、classにはイニシャライザが存在するので、直接値や関数を保持させることが出来る。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">class</span> TeenHuman{
  name: <span style="color:#458;font-weight:bold">string</span>;
  age: <span style="color:#458;font-weight:bold">number</span> <span style="font-weight:bold">=</span> <span style="color:#099">19</span>;

  <span style="font-weight:bold">constructor</span>( h_name: <span style="color:#458;font-weight:bold">string</span> ){
    <span style="font-weight:bold">this</span>.name <span style="font-weight:bold">=</span> h_name;
  }

  say( other )<span style="font-weight:bold">:</span> <span style="font-weight:bold">void</span> {
    console.log( <span style="color:#b84">&#34;hello, &#34;</span> <span style="font-weight:bold">+</span> other  );
  }
}

<span style="font-weight:bold">const</span> alice <span style="font-weight:bold">=</span> <span style="font-weight:bold">new</span> TeenHuman( <span style="color:#b84">&#34;alice&#34;</span> )

console.log( alice.name );
console.log( alice.age  );

alice.say(<span style="color:#b84">&#34;bob&#34;</span>);
</code></pre></div><p>宣言した場で値を放り込むことも出来るし、コンストラクタ経由で値を放り込むことも出来る。関数も直接実装できる。</p>
<p>特に何も指定しなければアクセサはpublicになる。</p>
<h3 id="メソッドのオーバーライド">メソッドのオーバーライド</h3>
<p>継承した親クラスのメソッドのオーバーライドは可能。</p>
<h3 id="メソッドのオーバーロード">メソッドのオーバーロード</h3>
<p>Rubyのように、オーバーロードは不可。</p>
<h3 id="クラスの属性">クラスの属性</h3>
<p><code>abstract</code>で抽象クラスを定義できる。</p>
<h3 id="data-modifiers要はアクセス属性">Data Modifiers(要はアクセス属性)</h3>
<p><code>public</code>,<code>private</code>,<code>protected</code>がある。おなじみのやつ。意味はjavaと似たようなものだと思う。</p>
<h3 id="static属性">static属性</h3>
<p>おなじみの<code>static</code>もある。クラスに定義を行う。javaと似たようなものだと思う。</p>
<h2 id="モジュールの利用">モジュールの利用</h2>
<p>当然だが、外部ファイル、モジュールの利用が出来る。</p>
<p>後述する<code>namespace</code>はこのモジュール内では使ってはいけないらしい。</p>
<h3 id="exportとimport">exportとimport</h3>
<p>あるファイルで定義された変数やクラスを他のファイルで使用したいとき、<code>import</code>と<code>export</code>を使用する。</p>
<p><code>module.ts</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">export</span> <span style="font-weight:bold">const</span> greeting: <span style="color:#458;font-weight:bold">string</span> <span style="font-weight:bold">=</span> <span style="color:#b84">&#34;Hello&#34;</span>;
</code></pre></div><p><code>test.ts</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">import</span> { greeting } from <span style="color:#b84">&#34;./module&#34;</span>

console.log( greeting )
</code></pre></div><p>javascriptでは、<code>require</code>によって別のファイルをインスタンス化してしまい、そのインスタンス経由で別のファイルで<code>export</code>指定を受けた変数や関数を取り出すことが出来る。これを、typescriptでは<code>import</code>と<code>export</code>で簡潔に表現できる。</p>
<p><code>export</code>の指定を受けていない変数や関数は別のファイルで<code>import</code>してもアクセスできない。</p>
<h3 id="2つのexport">2つのexport</h3>
<p><code>export</code>には <strong>名前付きexport</strong> と <strong>デフォルトexport</strong> がある。</p>
<h4 id="名前付きexport">名前付きexport</h4>
<p>exportしたいものを具体的に指定してexportする方法。上記で書いたexportはこれ。通常はコレを使う。変数やクラスなどの宣言時にプレフィックスとして<code>export</code>をつける方法や、既に宣言したものをまとめて指定することも出来る。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">export</span> <span style="font-weight:bold">class</span> Something { ... }

<span style="font-weight:bold">export</span> { <span style="color:#998;font-style:italic">/** 既に宣言されている変数やクラスや関数を、&#34;,&#34;で区切って指定 **/</span> };
<span style="font-weight:bold">export</span> { somefunc <span style="font-weight:bold">as</span> funcA }; <span style="color:#998;font-style:italic">// asを使うことでエイリアスをつけることが出来る
</span></code></pre></div><p>他にもある。</p>
<h4 id="デフォルトexport">デフォルトexport</h4>
<p>特に名前を指定せずに<code>import</code>されたときに指定されるものを、ひとつだけデフォルトエクスポートとして定めることが出来る。</p>
<p><code>module.ts</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">export</span> <span style="font-weight:bold">default</span> <span style="font-weight:bold">function</span> func( str: <span style="color:#458;font-weight:bold">string</span> )<span style="font-weight:bold">:</span> <span style="font-weight:bold">void</span> {
  console.log( str );
}
</code></pre></div><p><code>test.ts</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">import</span> def from <span style="color:#b84">&#34;./module&#34;</span>

def( <span style="color:#b84">&#34;something to put&#34;</span> );
</code></pre></div><p>上記の場合、特に名前を指定していないので<code>export default</code>で指定された関数が<code>def</code>に格納される。<code>import</code>の後ろに付けた名前は変数となり、上記の場合、<code>def</code>は関数部ジェクトのように振る舞うことになる。</p>
<h2 id="namespace">namespace</h2>
<p>名前空間も存在するが、ruby等のnamespaceとは少し雰囲気が違う。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript">namespace SomeNamespace {
  ...
}
</code></pre></div><p>下記コードを見れば分かるが、まるでmoduleのような感じになる。実際、もともとnamespaceは <strong>内部モジュール</strong> と呼ばれていたものらしい。<code>export</code>が無い場合、外からアクセスができない。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript">namespace SomeNs {
  <span style="font-weight:bold">export</span> <span style="font-weight:bold">function</span> func(){
    console.log(<span style="color:#b84">&#34;call SomeNs::function&#34;</span>);
  }
}

SomeNs.func();
</code></pre></div><p>classの定義も出来る。<code>export</code>を忘れずに。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript">namespace SomeNs {
  <span style="font-weight:bold">export</span> <span style="font-weight:bold">function</span> func(){
    console.log(<span style="color:#b84">&#34;call SomeNs::function&#34;</span>);
  }

  <span style="font-weight:bold">export</span> <span style="font-weight:bold">class</span> InnerClass {
    func(){
      console.log(<span style="color:#b84">&#34;call SomeNs::InnerClass.func&#34;</span>);
    }
  }
}

SomeNs.func();

<span style="font-weight:bold">const</span> nsIc <span style="font-weight:bold">=</span> <span style="font-weight:bold">new</span> SomeNs.InnerClass();

nsIc.func();
</code></pre></div><h3 id="複数ファイルに分解するためのnamespace">複数ファイルに分解するためのnamespace</h3>
<p><code>namespace</code>は<code>module</code>に挙動が似ているが、使い方が違う。<code>module</code>が独立した外部ライブラリのように振る舞うのに対し、<code>namespace</code>は<code>C</code>のヘッダファイルのように振る舞う。どういうことかと言うと、コンパイル時に他のファイルにインクルードされ、mixinされるイメージだ。</p>
<p>例えば下記のような2つのファイルがあったとする。</p>
<p><code>SomeNe.ts</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript">namespace SomeNs{
  <span style="font-weight:bold">export</span> <span style="font-weight:bold">function</span> func()<span style="font-weight:bold">:</span> <span style="font-weight:bold">void</span>{
    console.log(<span style="color:#b84">&#34;call SomeNs::function&#34;</span>)
  }
}
</code></pre></div><p><code>Test.ts</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#998;font-style:italic">/// &lt;reference path=&#34;SomeNs.ts&#34; /&gt;
</span><span style="color:#998;font-style:italic"></span>
SomeNs.func();
</code></pre></div><p>これをコンパイルするとき、通常なら２つのファイルが出力されるが、<code>namespace</code>を使用するときは<code>SomeNs.ts</code>が<code>Test.ts</code>にmixinされるので、一つのファイルとして出力される。</p>
<p>これをコンパイルするときは、その旨をコンパイラに伝えてあげないといけない。具体的には下記のようになる。</p>
<pre><code>$ tsc --outFile Test.js Test.ts SomeNs.ts
</code></pre><p>これで、２つのファイルをコンパイラが一つにまとめてくれる。</p>
<p><code>namespaceA</code>を<code>reference</code>して、拡張した<code>namespaceB</code>があったとして、それを使いたいときは、全ての<code>ts</code>ファイルをコンパイラに渡してあげれば、コンパイラが勝手に順序を判断してmixinしてくれる。</p>
<p>なので、モジュールは独立したライブラリとしての利用、ネームスペースは巨大な一つの構造を分離して管理する記法としての利用、と考えれば良さげ。</p>
<h2 id="型定義ファイル">型定義ファイル</h2>
<p><code>***.d.ts</code>というファイルがあればそれは<code>型定義ファイル</code>と呼ばれるものだ。型定義ファイルとは外部ライブラリのAPIを使用するときに引数や戻り値の型をtypescriptコンパイラに教えてくれるもの。コレがないと（ただのjsファイルのみだと）コンパイラはライブラリの関数が受け取るべき型や戻り値の型を判断できない。</p>
<p>typescript2.0以前は型定義ファイル管理ツールを<code>npm</code>などでインストールしてそれを使わないといけなかったが、2.0以降はそれらは不要になった。</p>
<h2 id="ダックタイピング">ダックタイピング</h2>
<p>typescriptはダックタイピングが可能。だが、rubyのように後からプロパティを生やすのは、やらない。（それをすると、型を壊してしまう）</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">class</span> TestClass {
  str: <span style="color:#458;font-weight:bold">string</span>;

  <span style="font-weight:bold">constructor</span>( s: <span style="color:#458;font-weight:bold">string</span> ){
    <span style="font-weight:bold">this</span>.str <span style="font-weight:bold">=</span> s;
  }

  getStr()<span style="font-weight:bold">:</span> <span style="color:#458;font-weight:bold">string</span> {
    <span style="font-weight:bold">return</span> <span style="font-weight:bold">this</span>.str;
  }
}

<span style="font-weight:bold">const</span> tc <span style="font-weight:bold">=</span> <span style="font-weight:bold">new</span> TestClass(<span style="color:#b84">&#34;this is original&#34;</span>);

console.log( tc.getStr() );
<span style="color:#998;font-style:italic">// =&gt; this is original
</span><span style="color:#998;font-style:italic"></span>
tc.getStr <span style="font-weight:bold">=</span> <span style="font-weight:bold">function</span> getStr()<span style="font-weight:bold">:</span> <span style="color:#458;font-weight:bold">string</span> { <span style="font-weight:bold">return</span> <span style="color:#b84">&#34;this is not original&#34;</span> };

console.log( tc.getStr() );
<span style="color:#998;font-style:italic">// =&gt; this is not original
</span></code></pre></div><h2 id="npmによってインストールされたモジュールはどのようにして読み込まれるのか">npmによってインストールされたモジュールはどのようにして読み込まれるのか</h2>
<p><code>npm</code>を利用して<code>node_modules</code>ディレクトリにダウンロードされたtsライブラリは、一般的には下記のようにして利用することができる。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="font-weight:bold">import</span> { SomeClass } from <span style="color:#b84">&#34;lib_name&#34;</span>
</code></pre></div><p>これによって、<code>lib_name</code>ライブラリの<code>SomeClass</code>クラスが利用可能になる。これはどういう仕組みになっているのか。</p>
<p>ここで、下記のようなツリー構造があるとする。</p>
<pre><code>root_dir
├ model
│ ├ tx.ts
│ ├ block.ts
│ └ node.ts
└ controller.ts
</code></pre><p>このとき、<code>controller.ts</code>は<code>model</code>ディレクトリの中の全てのtsファイルをインポートしたいとする。普通ではれば、</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="font-weight:bold">import</span> { <span style="color:#a61717;background-color:#e3d2d2">使いたいクラス群など</span> } from <span style="color:#b84">&#34;./model/tx.ts&#34;</span>
<span style="font-weight:bold">import</span> { <span style="color:#a61717;background-color:#e3d2d2">使いたいクラス群など</span> } from <span style="color:#b84">&#34;./model/block.ts&#34;</span>
<span style="font-weight:bold">import</span> { <span style="color:#a61717;background-color:#e3d2d2">使いたいクラス群など</span> } from <span style="color:#b84">&#34;./model/node.ts&#34;</span>
</code></pre></div><p>としなければいけない。これだと大変なので、typescriptにはこれを回避する仕組みが組み込まれている。</p>
<p>typescriptの中で<code>index.ts</code>という名前のファイルは特別なファイルで、イインポート時にディレクトリの指定だけしかないとき、typescriptは<code>index.ts</code>を探しに行く。ここに、エクスポートをまとめて書いておけばディレクトリの指定だけでまとめてエクスポート対象に出来るようになる。どういうことかというと、</p>
<pre><code>root_dir
├ model
│ ├ tx.ts
│ ├ block.ts
│ ├ node.ts
│ └ index.ts
└ controller.ts
</code></pre><p><code>index.ts</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="font-weight:bold">export</span> { exportしたいクラス群など(<span style="color:#a61717;background-color:#e3d2d2">ワイルドカードでも</span>) } from <span style="color:#b84">&#34;./tx.ts&#34;</span>
<span style="font-weight:bold">export</span> { exportしたいクラス群など(<span style="color:#a61717;background-color:#e3d2d2">ワイルドカードでも</span>) } from <span style="color:#b84">&#34;./block.ts&#34;</span>
<span style="font-weight:bold">export</span> { exportしたいクラス群など(<span style="color:#a61717;background-color:#e3d2d2">ワイルドカードでも</span>) } from <span style="color:#b84">&#34;./node.ts&#34;</span>
</code></pre></div><p>のような<code>index.ts</code>を加えて、<code>controller.ts</code>の中で、</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="font-weight:bold">import</span> { <span style="color:#a61717;background-color:#e3d2d2">使いたいクラス群</span> } from <span style="color:#b84">&#34;./model&#34;</span>
</code></pre></div><p>とするだけで良い。<code>import</code>すると、指定の名前のパスを調べて、それがディレクトリであれば<code>index.ts</code>を探すようになっているようだ。</p>
<p>さらに、指定が相対パス、絶対パスでなければ、<code>node_modules</code>内にその名前のディレクトリがないかを探索している。つまり、</p>
<ol>
<li><code>npm install</code>で<code>node_modules</code>ディレクトリにライブラリが入る</li>
<li><code>import</code>でライブラリのディレクトリ名だけ指定されて、<code>mode_modules</code>内にその名前のディレクトリがないか調べる</li>
<li>tsファイルの指定が無いので、<code>index.ts</code>が無いか調べる</li>
</ol>
<p>以上によって、最初の記述によって外部ライブラリが利用できるようになる。</p>
<h2 id="コンパイル">コンパイル</h2>
<p>コンパイル自体は</p>
<pre><code>$ tsc &lt;file name&gt;
</code></pre><h3 id="コンパイルの出力先設定">コンパイルの出力先設定</h3>
<p>コンパイルするだけなら上記で可能だが、これだとカレントディレクトリに生成してしまう。コンパイル先は指定したい。</p>
<p>このとき、<code>tsc</code>のオプションで済ませたい場合は<code>--outFile</code>オプションを利用する。</p>
<pre><code>$ tsc --outFile &lt;出力ファイルのパス&gt; &lt;tsソースファイル&gt;
</code></pre><p>しかし、コレに限らずコンパイル時にひとつひとつ情報をコンパイラに渡してあげるのは大変。</p>
<h3 id="tsconfigjson">tsconfig.json</h3>
<p>上記 <strong>コンパイルの出力先設定</strong> で書いたように、コンパイルオプションを一回一回渡してやるのは大変。そこで、<code>tsconfg.json</code>と呼ばれる<code>json</code>ファイルを作る。これによって煩わしさを解決する。</p>
<p><code>tsc</code>コマンドは、<code>tsconfig.json</code>は入力ファイルを指定せずに使用されると(<code>tsc</code>だけで実行すると)、カレントディレクトリから<code>tsconfig.json</code>ファイルを探し、そこに書いてある内容に従ってコンパイルを実行する。</p>
<p>もし、カレントディレクトリに<code>tsconfig.json</code>が無い場合、親ディレクトリに登って探し、更にそこでも見つからない場合、どんどんその親へ親へとディレクトリを登って<code>tsconfig.json</code>を探査する。</p>
<p><code>tsconfig.json</code>が置かれるのは基本的にはそのプロダクトのルートディレクトリで、<code>tsconfig.json</code>内に記入した相対パスは<code>tsconfig.json</code>ファイルの存在する場所からの相対パス、つまり、プロダクトのルートディレクトリを基準とした相対パスになる。</p>
<p>下記に示すような内容になっている。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#000080">&#34;compilerOptions&#34;</span>: {
    <span style="color:#000080">&#34;module&#34;</span>: <span style="color:#b84">&#34;commonjs&#34;</span>,
    <span style="color:#000080">&#34;noImplicitAny&#34;</span>: <span style="font-weight:bold">true</span>,
    <span style="color:#000080">&#34;removeComments&#34;</span>: <span style="font-weight:bold">true</span>,
    <span style="color:#000080">&#34;preserveConstEnums&#34;</span>: <span style="font-weight:bold">true</span>,
    <span style="color:#000080">&#34;sourceMap&#34;</span>: <span style="font-weight:bold">true</span>,
    <span style="color:#000080">&#34;rootDir&#34;</span>: <span style="color:#b84">&#34;.&#34;</span>,
    <span style="color:#000080">&#34;outDir&#34;</span>: <span style="color:#b84">&#34;./build/&#34;</span>
  },
  <span style="color:#000080">&#34;files&#34;</span>: [
    <span style="color:#b84">&#34;core.ts&#34;</span>,
    <span style="color:#b84">&#34;sys.ts&#34;</span>,
    <span style="color:#b84">&#34;types.ts&#34;</span>,
    <span style="color:#b84">&#34;scanner.ts&#34;</span>,
    <span style="color:#b84">&#34;parser.ts&#34;</span>,
    <span style="color:#b84">&#34;utilities.ts&#34;</span>,
    <span style="color:#b84">&#34;binder.ts&#34;</span>,
    <span style="color:#b84">&#34;checker.ts&#34;</span>,
    <span style="color:#b84">&#34;emitter.ts&#34;</span>,
    <span style="color:#b84">&#34;program.ts&#34;</span>,
    <span style="color:#b84">&#34;commandLineParser.ts&#34;</span>,
    <span style="color:#b84">&#34;tsc.ts&#34;</span>,
    <span style="color:#b84">&#34;diagnosticInformationMap.generated.ts&#34;</span>
  ]
}
</code></pre></div><h4 id="compileroptions-プロパティ">compilerOptions プロパティ</h4>
<p><code>compilerOptions</code>はコンパイラオプションをまとめておける。これはもちろん<code>tsc</code>のオプションで、そこにどんなものを書くかは<code>tsc</code>のオプションを調べれば分かる。</p>
<h4 id="files-プロパティ">files プロパティ</h4>
<p><code>files</code>を指定すれば、コンパイルしたいファイルを指定できる。例えば、<code>core.ts</code>とあれば、ルートディレクトリからのパス、つまり、<code>./core.ts</code>を探す。もし、ディレクトリ内にあるファイルであれば<code>dir/core.ts</code>のようにして書けば良い。</p>
<h4 id="パス指定時に使えるワイルドカード">パス指定時に使えるワイルドカード</h4>
<p><code>tsconfig</code>で使用するパスにはワイルドカードが使用できる。普通に<code>some/dir/*</code>のようなものから、<code>**/</code>（サブディレクトリに再帰的にマッチ）のようなワイルドカードも用意されているので、実際に使うときに調べてみる。</p>
<h3 id="コンパイラオプション">コンパイラオプション</h3>
<h4 id="module">module</h4>
<p>javascriptはもともとmoduleの概念がなく、ライブラリとしてモジュール的な機能を提供していた。（今はjavascriptにネイティブのモジュール機能がつくようになっているらしい）そのため、色々なモジュールの規格が存在してしまっている。<code>Node.js</code>では<code>CommonJS</code>が標準になっているので、それを使えばよいが、フロントエンドで使うときはモジュールの仕様を調べて決めてあげないといけない。</p>
<p><code>None</code>,<code>CommonJS</code>, <code>AMD</code>, <code>System</code>, <code>UMD</code>, <code>ES6</code>, <code>ES2015</code> , <code>ESNext</code> の中から選択可能。</p>
<h2 id="export--import-vs-require">export &amp; import vs require</h2>
<p>tsでは<code>export</code>によって<code>class</code>や<code>module</code>や<code>function</code>などを外部ファイルが参照できるようになる。これにもやり方がいくつか並列に存在していてややこしい。</p>
<p>これは、たとえば<code>Node.js</code>のモジュールの仕様だとか、<code>ES XXX</code>の仕様の違いだとか、色々なりゆうでいくつもモジュールの扱いが存在してしまっているせいでこんなことになっている。（これはコンパイラオプションでも前述したとおり）</p>
<p>いくつか説明を書く。ざっと挙げると、</p>
<ul>
<li><code>module.export + require</code>を使った<code>Node.js</code>仕様</li>
<li><code>export + import</code>を使った<code>ES6</code>仕様</li>
</ul>
<p>の２つがあると考えれば良い。他にもあるかもしれないが、とりあえず必要ないので&hellip;</p>
<h3 id="nodejsのモジュールシステム">Node.jsのモジュールシステム</h3>
<p><code>export側</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="font-weight:bold">function</span> someFunc(){...}

<span style="font-weight:bold">module</span>.export <span style="font-weight:bold">=</span> someFunc;
</code></pre></div><p><code>import側</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="font-weight:bold">const</span> externalFunc <span style="font-weight:bold">=</span> require(<span style="color:#b84">&#39;file/path/of/imported&#39;</span>);
</code></pre></div><h3 id="es6のモジュールシステム">ES6のモジュールシステム</h3>
<p><code>export側</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="font-weight:bold">export</span> <span style="font-weight:bold">function</span> someFunc(){...}
</code></pre></div><p><code>import側</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="font-weight:bold">import</span> <span style="font-weight:bold">*</span> <span style="font-weight:bold">as</span> external from <span style="color:#b84">&#39;file/path/of/imported&#39;</span>;
</code></pre></div><p><code>import</code>側は基本的な書き方は似ているが色々な書き方がある。</p>

        
        

<section class="section sns_parent" id="shareButtonsSection">
  <div class="container sns_section" id="shareButtonsContainer">
      <div class="sns_button twitter">
        <a href="http://twitter.com/intent/tweet?url=https%3a%2f%2fmijinc0.github.io%2fblog%2f20190502_learn_typescript%2f&text=TypeScript%e3%82%92%e5%ad%a6%e3%81%b6" target="_blank" title="Tweet" id="shareTwetterButton">tweet</a>
      </div>
  </div>
</section>



      </article>
      
    </main>
    <nav class="end-nav side-padding">
      
      <a ontouchstart="cardPressed.call(this)" ontouchend="cardReleased.call(this)" ontouchmove="cardReleased.call(this)" 
  href="https://mijinc0.github.io/blog/" class="card home-card" style="background-image: url( https://github.com/mijinc0/blog/blob/image/general/homeimage.png?raw=true )" rel="bookmark" >
  Home
</a>
    </nav>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
  
  <script src="https://mijinc0.github.io/blog/js/core.min.js"></script>
<script>
  hljs.initHighlightingOnLoad();
</script>

  </body>
</html>